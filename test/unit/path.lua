local helpers = require('test.lib.helpers')

require('lfs')

local path = helpers.cimport('./src/nvim/path.h')

-- Constants
local NULL = helpers.ffi.cast('void*', 0)
local OK = 1
local FAIL = 0

describe('path function', function()
  describe('path_full_compare', function()
    local path_full_compare
    path_full_compare = function(s1, s2, cn)
      s1 = helpers.to_cstr(s1)
      s2 = helpers.to_cstr(s2)
      return path.path_full_compare(s1, s2, cn or 0)
    end
    local f1 = 'f1.o'
    local f2 = 'f2.o'
    before_each(function()
      (io.open(f1, 'w')).close()
      return (io.open(f2, 'w')).close()
    end)
    after_each(function()
      os.remove(f1)
      return os.remove(f2)
    end)
    it('returns path.kHelpers.EqualFiles when passed the same file', function()
      return helpers.eq(path.kEqualFiles, (path_full_compare(f1, f1)))
    end)
    it('returns path.kEqualFileNames when files that dont exist and have same name', function()
      return helpers.eq(path.kEqualFileNames, (path_full_compare('null.txt', 'null.txt', true)))
    end)
    it('returns path.kBothFilesMissing when files that dont exist', function()
      return helpers.eq(path.kBothFilesMissing, (path_full_compare('null.txt', 'null.txt')))
    end)
    it('returns path.kDifferentFiles when passed different files', function()
      helpers.eq(path.kDifferentFiles, (path_full_compare(f1, f2)))
      return helpers.eq(path.kDifferentFiles, (path_full_compare(f2, f1)))
    end)
    return it('returns path.kOneFileMissing if only one does not exist', function()
      helpers.eq(path.kOneFileMissing, (path_full_compare(f1, 'null.txt')))
      return helpers.eq(path.kOneFileMissing, (path_full_compare('null.txt', f1)))
    end)
  end)
  describe('path_tail', function()
    local path_tail
    path_tail = function(file)
      local res = path.path_tail((helpers.to_cstr(file)))
      helpers.neq(NULL, res)
      return helpers.ffi.string(res)
    end
    it('returns the tail of a given file path', function()
      return helpers.eq('file.txt', path_tail('directory/file.txt'))
    end)
    return it('returns an empty string if file ends in a slash', function()
      return helpers.eq('', path_tail('directory/'))
    end)
  end)
  describe('path_tail_with_sep', function()
    local path_tail_with_sep
    path_tail_with_sep = function(file)
      local res = path.path_tail_with_sep((helpers.to_cstr(file)))
      helpers.neq(NULL, res)
      return helpers.ffi.string(res)
    end
    it('returns the tail of a file together with its seperator', function()
      return helpers.eq('///file.txt', path_tail_with_sep('directory///file.txt'))
    end)
    it('returns an empty string when given an empty file name', function()
      return helpers.eq('', path_tail_with_sep(''))
    end)
    it('returns only the seperator if there is a traling seperator', function()
      return helpers.eq('/', path_tail_with_sep('some/directory/'))
    end)
    it('cuts a leading seperator', function()
      helpers.eq('file.txt', path_tail_with_sep('/file.txt'))
      return helpers.eq('', path_tail_with_sep('/'))
    end)
    return it('returns the whole file name if there is no seperator', function()
      return helpers.eq('file.txt', path_tail_with_sep('file.txt'))
    end)
  end)
  describe('path_next_component', function()
    local path_next_component
    path_next_component = function(file)
      local res = path.path_next_component((helpers.to_cstr(file)))
      helpers.neq(NULL, res)
      return helpers.ffi.string(res)
    end
    it('returns', function()
      return helpers.eq('directory/file.txt', path_next_component('some/directory/file.txt'))
    end)
    return it('returns empty string if given file contains no seperator', function()
      return helpers.eq('', path_next_component('file.txt'))
    end)
  end)
  return describe('path_shorten_fname', function()
    it('returns NULL if `full_path` is NULL', function()
      local dir = helpers.to_cstr('some/directory/file.txt')
      return helpers.eq(NULL, (path.path_shorten_fname(NULL, dir)))
    end)
    it('returns NULL if the path and dir does not match', function()
      local dir = helpers.to_cstr('not/the/same')
      local full = helpers.to_cstr('as/this.txt')
      return helpers.eq(NULL, (path.path_shorten_fname(full, dir)))
    end)
    it('returns NULL if the path is not separated properly', function()
      local dir = helpers.to_cstr('some/very/long/')
      local full = helpers.to_cstr('some/very/long/directory/file.txt')
      return helpers.eq(NULL, (path.path_shorten_fname(full, dir)))
    end)
    return it('shortens the filename if `dir_name` is the start of `full_path`', function()
      local full = helpers.to_cstr('some/very/long/directory/file.txt')
      local dir = helpers.to_cstr('some/very/long')
      return helpers.eq('directory/file.txt', (helpers.ffi.string(path.path_shorten_fname(full, dir))))
    end)
  end)
end)
describe('path_shorten_fname_if_possible', function()
  local cwd = lfs.currentdir()
  before_each(function()
    return lfs.mkdir('ut_directory')
  end)
  after_each(function()
    lfs.chdir(cwd)
    return lfs.rmdir('ut_directory')
  end)
  return describe('path_shorten_fname_if_possible', function()
    it('returns shortened path if possible', function()
      lfs.chdir('ut_directory')
      local full = helpers.to_cstr(lfs.currentdir() .. '/subdir/file.txt')
      return helpers.eq('subdir/file.txt', (helpers.ffi.string(path.path_shorten_fname_if_possible(full))))
    end)
    it('returns `full_path` if a shorter version is not possible', function()
      local old = lfs.currentdir()
      lfs.chdir('ut_directory')
      local full = old .. '/subdir/file.txt'
      return helpers.eq(full, (helpers.ffi.string(path.path_shorten_fname_if_possible(helpers.to_cstr(full)))))
    end)
    return it('returns NULL if `full_path` is NULL', function()
      return helpers.eq(NULL, (path.path_shorten_fname_if_possible(NULL)))
    end)
  end)
end)
return describe('more path function', function()
  setup(function()
    lfs.mkdir('unit-test-directory');
    (io.open('unit-test-directory/test.file', 'w')).close()
    absolute_executable = arg[0]
    directory, executable_name = string.match(absolute_executable, '^(.*)/(.*)$')
  end)
  teardown(function()
    os.remove('unit-test-directory/test.file')
    return lfs.rmdir('unit-test-directory')
  end)
  describe('vim_FullName', function()
    local vim_FullName
    vim_FullName = function(filename, buffer, length, force)
      filename = helpers.to_cstr(filename)
      return path.vim_FullName(filename, buffer, length, force)
    end
    before_each(function()
      len = (string.len(lfs.currentdir())) + 33
      buffer = helpers.cstr(len, '')
    end)
    it('fails if given filename is NULL', function()
      local force_expansion = 1
      local result = path.vim_FullName(NULL, buffer, len, force_expansion)
      return helpers.eq(FAIL, result)
    end)
    it('uses the filename if the filename is a URL', function()
      local force_expansion = 1
      local filename = 'http://www.neovim.org'
      local result = vim_FullName(filename, buffer, len, force_expansion)
      helpers.eq(filename, (helpers.ffi.string(buffer)))
      return helpers.eq(OK, result)
    end)
    it('fails and uses filename if given filename contains non-existing directory', function()
      local force_expansion = 1
      local filename = 'non_existing_dir/test.file'
      local result = vim_FullName(filename, buffer, len, force_expansion)
      helpers.eq(filename, (helpers.ffi.string(buffer)))
      return helpers.eq(FAIL, result)
    end)
    it('concatenates given filename if it does not contain a slash', function()
      local force_expansion = 1
      local result = vim_FullName('test.file', buffer, len, force_expansion)
      local expected = lfs.currentdir() .. '/test.file'
      helpers.eq(expected, (helpers.ffi.string(buffer)))
      return helpers.eq(OK, result)
    end)
    it('concatenates given filename if it is a directory but does not contain a\n    slash', function()
      local force_expansion = 1
      local result = vim_FullName('..', buffer, len, force_expansion)
      local expected = lfs.currentdir() .. '/..'
      helpers.eq(expected, (helpers.ffi.string(buffer)))
      return helpers.eq(OK, result)
    end)
    it('enters given directory (instead of just concatenating the strings) if\n    possible and if path contains a slash', function()
      local force_expansion = 1
      local result = vim_FullName('../test.file', buffer, len, force_expansion)
      local old_dir = lfs.currentdir()
      lfs.chdir('..')
      local expected = lfs.currentdir() .. '/test.file'
      lfs.chdir(old_dir)
      helpers.eq(expected, (helpers.ffi.string(buffer)))
      return helpers.eq(OK, result)
    end)
    it('just copies the path if it is already absolute and force=0', function()
      local force_expansion = 0
      local absolute_path = '/absolute/path'
      local result = vim_FullName(absolute_path, buffer, len, force_expansion)
      helpers.eq(absolute_path, (helpers.ffi.string(buffer)))
      return helpers.eq(OK, result)
    end)
    it('fails and uses filename when the path is relative to HOME', function()
      local force_expansion = 1
      local absolute_path = '~/home.file'
      local result = vim_FullName(absolute_path, buffer, len, force_expansion)
      helpers.eq(absolute_path, (helpers.ffi.string(buffer)))
      return helpers.eq(FAIL, result)
    end)
    it('works with some "normal" relative path with directories', function()
      local force_expansion = 1
      local result = vim_FullName('unit-test-directory/test.file', buffer, len, force_expansion)
      helpers.eq(OK, result)
      return helpers.eq(lfs.currentdir() .. '/unit-test-directory/test.file', (helpers.ffi.string(buffer)))
    end)
    return it('does not modify the given filename', function()
      local force_expansion = 1
      local filename = helpers.to_cstr('unit-test-directory/test.file')
      local result = path.vim_FullName(filename, buffer, len, force_expansion)
      helpers.eq(lfs.currentdir() .. '/unit-test-directory/test.file', (helpers.ffi.string(buffer)))
      helpers.eq('unit-test-directory/test.file', (helpers.ffi.string(filename)))
      return helpers.eq(OK, result)
    end)
  end)
  describe('append_path', function()
    it('joins given paths with a slash', function()
      local path1 = helpers.cstr(100, 'path1')
      local to_append = helpers.to_cstr('path2')
      helpers.eq(OK, (path.append_path(path1, to_append, 100)))
      return helpers.eq("path1/path2", (helpers.ffi.string(path1)))
    end)
    it('joins given paths without adding an unnecessary slash', function()
      local path1 = helpers.cstr(100, 'path1/')
      local to_append = helpers.to_cstr('path2')
      helpers.eq(OK, path.append_path(path1, to_append, 100))
      return helpers.eq("path1/path2", (helpers.ffi.string(path1)))
    end)
    it('fails and uses filename if there is not enough space left for to_append', function()
      local path1 = helpers.cstr(11, 'path1/')
      local to_append = helpers.to_cstr('path2')
      return helpers.eq(FAIL, (path.append_path(path1, to_append, 11)))
    end)
    it('does not append a slash if to_append is empty', function()
      local path1 = helpers.cstr(6, 'path1')
      local to_append = helpers.to_cstr('')
      helpers.eq(OK, (path.append_path(path1, to_append, 6)))
      return helpers.eq('path1', (helpers.ffi.string(path1)))
    end)
    it('does not append unnecessary dots', function()
      local path1 = helpers.cstr(6, 'path1')
      local to_append = helpers.to_cstr('.')
      helpers.eq(OK, (path.append_path(path1, to_append, 6)))
      return helpers.eq('path1', (helpers.ffi.string(path1)))
    end)
    return it('copies to_append to path, if path is empty', function()
      local path1 = helpers.cstr(7, '')
      local to_append = helpers.to_cstr('/path2')
      helpers.eq(OK, (path.append_path(path1, to_append, 7)))
      return helpers.eq('/path2', (helpers.ffi.string(path1)))
    end)
  end)
  return describe('path_is_absolute_path', function()
    local path_is_absolute_path
    path_is_absolute_path = function(filename)
      filename = helpers.to_cstr(filename)
      return path.path_is_absolute_path(filename)
    end
    it('returns true if filename starts with a slash', function()
      return helpers.eq(OK, path_is_absolute_path('/some/directory/'))
    end)
    it('returns true if filename starts with a tilde', function()
      return helpers.eq(OK, path_is_absolute_path('~/in/my/home~/directory'))
    end)
    return it('returns false if filename starts not with slash nor tilde', function()
      return helpers.eq(FAIL, path_is_absolute_path('not/in/my/home~/directory'))
    end)
  end)
end)
